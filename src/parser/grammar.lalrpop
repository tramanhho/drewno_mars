use crate::scanner::tokens::TokenType;
use crate::parser::ast;
use crate::parser::lexer::LexicalError;
grammar;

extern {
  type Location = usize;
  type Error = LexicalError;

  enum TokenType {
    //"identifier" => TokenType::Identifier(<String>),
    "AND" => TokenType::AND,
    "MAGIC" => TokenType::MAGIC,
    "BOOL" => TokenType::BOOL,
    "ELSE" => TokenType::ELSE,
    "FALSE" => TokenType::FALSE,
    "IF" => TokenType::IF,
    "INT" => TokenType::INT,
    "GIVE" => TokenType::GIVE,
    "TAKE" => TokenType::TAKE,
    "OR" => TokenType::OR,
    "PERFECT" => TokenType::PERFECT,
    "RETURN" => TokenType::RETURN,
    "CLASS" => TokenType::CLASS,
    "TRUE" => TokenType::TRUE,
    "EXIT" => TokenType::EXIT,
    "VOID" => TokenType::VOID,
    "WHILE" => TokenType::WHILE,
    "ID" => TokenType::ID,
    "INTLITERAL" => TokenType::INTLITERAL,
    "STRINGLITERAL" => TokenType::STRINGLITERAL,
    "ASSIGN" => TokenType::ASSIGN,
    "COLON" => TokenType::COLON,
    "COMMA" => TokenType::COMMA,
    "CROSS" => TokenType::CROSS,
    "DASH" => TokenType::DASH,
    "EQUALS" => TokenType::EQUALS,
    "GREATER" => TokenType::GREATER,
    "GREATEREQ" => TokenType::GREATEREQ,
    "LCURLY" => TokenType::LCURLY,
    "LESS" => TokenType::LESS,
    "LESSEQ" => TokenType::LESSEQ,
    "LPAREN" => TokenType::LPAREN,
    "NOT" => TokenType::NOT,
    "NOTEQUALS" => TokenType::NOTEQUALS,
    "POSTDEC" => TokenType::POSTDEC,
    "POSTINC" => TokenType::POSTINC,
    "RCURLY" => TokenType::RCURLY,
    "RPAREN" => TokenType::RPAREN,
    "SEMICOL" => TokenType::SEMICOL,
    "SLASH" => TokenType::SLASH,
    "STAR" => TokenType::STAR,
  }
}

//program
pub program: Box<ast::ASTprogram> = {
    globals => Box::new(ast::ASTprogram::program(<>)),
}

//globals
pub globals: Box<ast::ASTglobals> = {
    globals decl => Box::new(ast::ASTglobals::globals_decl(<>)),
    => Box::new(ast::ASTglobals::globals_epsilon(<>)),
}

//decl
pub decl: Box<ast::ASTdecl> = {
    varDecl "SEMICOL" => Box::new(ast::ASTdecl::decl_varDecl(<>)),
    classDecl => Box::new(ast::ASTdecl::decl_classDecl(<>)),
    fnDecl => Box::new(ast::ASTdecl::decl_fnDecl(<>)),
}

//varDecl
pub varDecl: Box<ast::ASTvarDecl> = {
    id "COLON" dm_type => Box::new(ast::ASTvarDecl::varDecl_colon(<>)),
    id "COLON" dm_type "ASSIGN" exp => Box::new(ast::ASTvarDecl::varDecl_colonassign(<>)),
}

//type
pub dm_type: Box<ast::ASTtype> = {
    primType => Box::new(ast::ASTtype::type_primType(<>)),
    "PERFECT" primType => Box::new(ast::ASTtype::type_perfectprimType(<>)),
    id => Box::new(ast::ASTtype::type_id(<>)),
    "PERFECT" id => Box::new(ast::ASTtype::type_perfectid(<>)),

}

//primType
pub primType: Box<ast::ASTprimType> = {
    "INT" => Box::new(ast::ASTprimType::primType_int(<>)),
    "BOOL" => Box::new(ast::ASTprimType::primType_bool(<>)),
    "VOID" => Box::new(ast::ASTprimType::primType_void(<>)),
}

//classDecl
pub classDecl: Box<ast::ASTclassDecl> = {
    id "COLON" "CLASS" "LCURLY" classBody "RCURLY" "SEMICOL" => Box::new(ast::ASTclassDecl::classDecl(<>)),
}

//classBody
pub classBody: Box<ast::ASTclassBody> = {
    classBody varDecl => Box::new(ast::ASTclassBody::classBody_varDecl(<>)),
    classBody fnDecl => Box::new(ast::ASTclassBody::classBody_fnDecl(<>)),
    => Box::new(ast::ASTclassBody::classBody_epsilon(<>)),

}

//fnDecl
pub fnDecl: Box<ast::ASTfnDecl> = {
    id "COLON" "LPAREN" formals "RPAREN" dm_type "LCURLY" stmtList "RCURLY"  => Box::new(ast::ASTfnDecl::fnDecl_formals(<>)),
    //id "COLON" "LPAREN" "RPAREN" dm_type "LCURLY" stmtList "RCURLY"  => Box::new(ast::ASTfnDecl::fnDecl(<>)),

}

//formals
pub formals: Box<ast::ASTformals> = {
    formalsList  => Box::new(ast::ASTformals::formals_formalsList(<>)),
    => Box::new(ast::ASTformals::formals_epsilon(<>)),
}

//formalsList
pub formalsList: Box<ast::ASTformalsList> = {
    formalDecl  => Box::new(ast::ASTformalsList::formalsList_formalDecl(<>)),
    formalsList "COMMA" formalDecl  => Box::new(ast::ASTformalsList::formalsList(<>)),

}

//formalDecl
pub formalDecl: Box<ast::ASTformalDecl> = {
    id "COLON" dm_type  => Box::new(ast::ASTformalDecl::formalDecl(<>)),
}


//stmtList
pub stmtList: Box<ast::ASTstmtList> = {
    stmtList stmt "SEMICOL"  => Box::new(ast::ASTstmtList::stmtList_stmtList(<>)),
    stmtList blockStmt  => Box::new(ast::ASTstmtList::stmtList_blockStmt(<>)),
    => Box::new(ast::ASTstmtList::stmtList_epsilon(<>)),
}

//blockStmt
pub blockStmt: Box<ast::ASTblockStmt> = {
    "WHILE" "LPAREN" exp "RPAREN" "LCURLY" stmtList "RCURLY"  => Box::new(ast::ASTblockStmt::blockStmt_while(<>)),
    "IF" "LPAREN" exp "RPAREN" "LCURLY" stmtList "RCURLY"  => Box::new(ast::ASTblockStmt::blockStmt_if(<>)),
    "IF" "LPAREN" exp "RPAREN" "LCURLY" stmtList "RCURLY" "ELSE" "LCURLY" stmtList "RCURLY"  => Box::new(ast::ASTblockStmt::blockStmt_ifelse(<>)),
}

//stmt
pub stmt: Box<ast::ASTstmt> = {
    varDecl  => Box::new(ast::ASTstmt::stmt_varDecl(<>)),
    loc "ASSIGN" exp  => Box::new(ast::ASTstmt::stmt_assign(<>)),
    loc "POSTDEC"  => Box::new(ast::ASTstmt::stmt_postdec(<>)),
    loc "POSTINC"  => Box::new(ast::ASTstmt::stmt_postinc(<>)),
    "GIVE" exp  => Box::new(ast::ASTstmt::stmt_give(<>)),
    "TAKE" loc  => Box::new(ast::ASTstmt::stmt_take(<>)),
    "RETURN" exp  => Box::new(ast::ASTstmt::stmt_returnexp(<>)),
    "RETURN"  => Box::new(ast::ASTstmt::stmt_return(<>)),
    "EXIT"  => Box::new(ast::ASTstmt::stmt_exit(<>)),
    callExp  => Box::new(ast::ASTstmt::stmt_callExp(<>)),
}

//exp
pub exp: Box<ast::ASTexp> = {
    term "DASH" exp  => Box::new(ast::ASTexp::exp_dash(<>)),
    term "CROSS" exp  => Box::new(ast::ASTexp::exp_cross(<>)),
    term "STAR" exp  => Box::new(ast::ASTexp::exp_star(<>)),
    term "SLASH" exp  => Box::new(ast::ASTexp::exp_slash(<>)),
    term "AND" exp  => Box::new(ast::ASTexp::exp_and(<>)),
    term "OR" exp  => Box::new(ast::ASTexp::exp_or(<>)),
    term "EQUALS" exp  => Box::new(ast::ASTexp::exp_equals(<>)),
    term "NOTEQUALS" exp  => Box::new(ast::ASTexp::exp_notequals(<>)),
    term "GREATER" exp  => Box::new(ast::ASTexp::exp_greater(<>)),
    term "GREATEREQ" exp  => Box::new(ast::ASTexp::exp_greatereq(<>)),
    term "LESS" exp  => Box::new(ast::ASTexp::exp_less(<>)),
    term "LESSEQ" exp  => Box::new(ast::ASTexp::exp_lesseq(<>)),
    "NOT" exp  => Box::new(ast::ASTexp::exp_not(<>)), //may need to fix to exp
    "DASH" term  => Box::new(ast::ASTexp::exp_dashterm(<>)),
    term  => Box::new(ast::ASTexp::exp_term(<>)),

};

//callExp
pub callExp: Box<ast::ASTcallExp> = {
    id "LPAREN" "RPAREN" => Box::new(ast::ASTcallExp::callExp_fn(<>)),
    id "LPAREN" actualsList "RPAREN" => Box::new(ast::ASTcallExp::callExp_fnargs(<>)),
};

//actualsList
pub actualsList: Box<ast::ASTactualsList> = {
    exp => Box::new(ast::ASTactualsList::actualsList_exp(<>)),
    actualsList "COMMA" exp => Box::new(ast::ASTactualsList::actualsList_actualsList(<>)),
};


//term
pub term: Box<ast::ASTterm> = {
    loc => Box::new(ast::ASTterm::term_loc(<>)),
    "INTLITERAL" => Box::new(ast::ASTterm::term_intliteral(TokenType::INTLITERAL)),
    "STRINGLITERAL" => Box::new(ast::ASTterm::term_stringliteral(TokenType::STRINGLITERAL)),
    "TRUE" => Box::new(ast::ASTterm::term_true(TokenType::TRUE)),
    "FALSE" => Box::new(ast::ASTterm::term_false(TokenType::FALSE)),
    "MAGIC" => Box::new(ast::ASTterm::term_magic(TokenType::MAGIC)),
    "LPAREN" exp "RPAREN" => Box::new(ast::ASTterm::term_paren(<>)),
    callExp => Box::new(ast::ASTterm::term_callExp(<>)),

};

//loc
pub loc: Box<ast::ASTloc> = {
    id => Box::new(ast::ASTloc::loc_id(<>)),
    loc "POSTDEC" id => Box::new(ast::ASTloc::loc_postdec(<>)),
};

//id
pub id: Box<ast::ASTid> = {
    "ID" => Box::new(ast::ASTid::id(TokenType::ID)),
};
