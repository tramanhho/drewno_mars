use crate::scanner::tokens::{TokenType, LexingError};
use crate::parser::ast;
//use crate::parser::lexer::LexicalError;
grammar;

extern {
  type Location = usize;
  type Error = LexingError;

  enum TokenType {
    "AND" => TokenType::AND,
    "MAGIC" => TokenType::MAGIC,
    "BOOL" => TokenType::BOOL,
    "ELSE" => TokenType::ELSE,
    "FALSE" => TokenType::FALSE,
    "IF" => TokenType::IF,
    "INT" => TokenType::INT,
    "GIVE" => TokenType::GIVE,
    "TAKE" => TokenType::TAKE,
    "OR" => TokenType::OR,
    "PERFECT" => TokenType::PERFECT,
    "RETURN" => TokenType::RETURN,
    "CLASS" => TokenType::CLASS,
    "TRUE" => TokenType::TRUE,
    "EXIT" => TokenType::EXIT,
    "VOID" => TokenType::VOID,
    "WHILE" => TokenType::WHILE,
    "ID" => TokenType::ID(<String>),
    "INTLITERAL" => TokenType::INTLITERAL(<i32>),
    "STRINGLITERAL" => TokenType::STRINGLITERAL(<String>),
    "ASSIGN" => TokenType::ASSIGN,
    "COLON" => TokenType::COLON,
    "COMMA" => TokenType::COMMA,
    "CROSS" => TokenType::CROSS,
    "DASH" => TokenType::DASH,
    "EQUALS" => TokenType::EQUALS,
    "GREATER" => TokenType::GREATER,
    "GREATEREQ" => TokenType::GREATEREQ,
    "LCURLY" => TokenType::LCURLY,
    "LESS" => TokenType::LESS,
    "LESSEQ" => TokenType::LESSEQ,
    "LPAREN" => TokenType::LPAREN,
    "NOT" => TokenType::NOT,
    "NOTEQUALS" => TokenType::NOTEQUALS,
    "POSTDEC" => TokenType::POSTDEC,
    "POSTINC" => TokenType::POSTINC,
    "RCURLY" => TokenType::RCURLY,
    "RPAREN" => TokenType::RPAREN,
    "SEMICOL" => TokenType::SEMICOL,
    "SLASH" => TokenType::SLASH,
    "STAR" => TokenType::STAR,
  }
}

Comma<T>: Vec<T> = { 
    <mut v:(<T> "COMMA")*> <e:T?> => match e { 
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};

// //program
// pub Program: Box<ast::Program> = {
//     Globals => Box::new(ast::Program::Program(<>)),
// }

// //globals
// pub Globals: Box<ast::Globals> = {
//     Globals Decl => Box::new(ast::Globals::Globals_Decl(<>)),
//     => Box::new(ast::Globals::Globals_Epsilon(<>)),
// }

// //decl
// pub Decl: Box<ast::Decl> = {
//     VarDecl "SEMICOL" => Box::new(ast::Decl::Decl_VarDecl(<>)),
//     ClassDecl => Box::new(ast::Decl::Decl_ClassDecl(<>)),
//     FnDecl => Box::new(ast::Decl::Decl_FnDecl(<>)),
// }

pub VarDecl: Box<ast::VarDecl> = {
    <id:Id> "COLON" <var_type: Type> => Box::new(
        ast::VarDecl::Variable{
            id, 
            var_type
        }
    ),
    // <id:Id> "COLON" <var_type: Type> "ASSIGN" <init_val: Exp> => Box::new(
    //     ast::VarDecl::Variable(
    //         id, 
    //         var_type
    //         init_val
    //     )
    // ),
}

pub Type: Box<ast::Type> = {
    PrimType => Box::new(ast::Type::Prim(<>)),
    Id => Box::new(ast::Type::Class(<>)),
    "PERFECT" <prim_type: PrimType> => Box::new(ast::Type::PerfectPrim(prim_type)),
    "PERFECT" <name:"ID"> => Box::new(ast::Type::PerfectClass(name)),
}

pub PrimType: ast::PrimType = {
    "INT" => ast::PrimType::Int,
    "BOOL" => ast::PrimType::Bool,
    "VOID" => ast::PrimType::Void,
}

// //ClassDecl
// pub ClassDecl: Box<ast::ClassDecl> = {
//     Id "COLON" "CLASS" "LCURLY" ClassBody "RCURLY" "SEMICOL" => Box::new(ast::ClassDecl::ClassDecl(<>)),
// }

// //classBody
// pub ClassBody: Box<ast::ClassBody> = {
//     ClassBody VarDecl "SEMICOL" => Box::new(ast::ClassBody::ClassBody_VarDecl(<>)),
//     ClassBody FnDecl "SEMICOL" => Box::new(ast::ClassBody::ClassBody_FnDecl(<>)),
//     => Box::new(ast::ClassBody::ClassBody_Epsilon(<>)),

// }

// //FnDecl
// pub FnDecl: Box<ast::FnDecl> = {
//     Id "COLON" "LPAREN" Formals "RPAREN" Type "LCURLY" StmtList "RCURLY" => Box::new(ast::FnDecl::FnDecl_Formals(<>)),
//     //Id "COLON" "LPAREN" "RPAREN" Type "LCURLY" StmtList "RCURLY" => Box::new(ast::FnDecl::FnDecl(<>)),
// }

pub FormalsList = {
    Comma<FormalDecl>
    // see if we need to do epsilon later 
    // as of right now, a formalsList/formals node will NOT be created
    // this should be fine because FormalsNode/FormalsListNode isn't a thing in the inheritance/collaboration diagram
}

pub FormalDecl: Box<ast::FormalDecl> = {
    <name:"ID"> "COLON" <formal_type: Type> => Box::new(
        ast::FormalDecl::FormalDecl(name, formal_type)
    ),
}


// //stmtList
// pub StmtList: Box<ast::StmtList> = {
//     StmtList Stmt "SEMICOL" => Box::new(ast::StmtList::StmtList_StmtList(<>)),
//     StmtList BlockStmt => Box::new(ast::StmtList::StmtList_BlockStmt(<>)),
//     => Box::new(ast::StmtList::StmtList_Epsilon(<>)),
// }

// //blockStmt
// pub BlockStmt: Box<ast::BlockStmt> = {
//     "WHILE" "LPAREN" Exp "RPAREN" "LCURLY" StmtList "RCURLY" => Box::new(ast::BlockStmt::BlockStmt_While(<>)),
//     "IF" "LPAREN" Exp "RPAREN" "LCURLY" StmtList "RCURLY" => Box::new(ast::BlockStmt::BlockStmt_If(<>)),
//     "IF" "LPAREN" Exp "RPAREN" "LCURLY" StmtList "RCURLY" "ELSE" "LCURLY" StmtList "RCURLY" => Box::new(ast::BlockStmt::BlockStmt_IfElse(<>)),
// }

// //stmt
// pub Stmt: Box<ast::Stmt> = {
//     VarDecl => Box::new(ast::Stmt::Stmt_VarDecl(<>)),
//     Loc "ASSIGN" Exp => Box::new(ast::Stmt::Stmt_Assign(<>)),
//     Loc "POSTDEC" => Box::new(ast::Stmt::Stmt_PostDec(<>)),
//     Loc "POSTINC" => Box::new(ast::Stmt::Stmt_PostInc(<>)),
//     "GIVE" Exp => Box::new(ast::Stmt::Stmt_Give(<>)),
//     "TAKE" Loc => Box::new(ast::Stmt::Stmt_Take(<>)),
//     "RETURN" Exp => Box::new(ast::Stmt::Stmt_ReturnExp(<>)),
//     "RETURN" => Box::new(ast::Stmt::Stmt_Return(<>)),
//     "EXIT" => Box::new(ast::Stmt::Stmt_Exit(<>)),
//     CallExp => Box::new(ast::Stmt::Stmt_CallExp(<>)),
// }

//Exp
pub Exp: Box<ast::Exp> = {
    #[precedence(level="1")]
    Term,

    #[precedence(level="2")] #[assoc(side="right")]
    <lhs:Term> "STAR" <rhs:Exp> => Box::new(
        ast::Exp::BinaryExp(Box::new(ast::BinaryExp::Times{
            lhs,
            rhs
        }))
    ),

    <lhs:Term> "SLASH" <rhs:Exp> => Box::new(
        ast::Exp::BinaryExp(Box::new(ast::BinaryExp::Divide{
            lhs,
            rhs
        }))
    ),

    <lhs:Term> "AND" <rhs:Exp> => Box::new(
        ast::Exp::BinaryExp(Box::new(ast::BinaryExp::And{
            lhs,
            rhs
        }))
    ),

    #[precedence(level="3")]
    <lhs:Term> "CROSS" <rhs:Exp> => Box::new(
        ast::Exp::BinaryExp(Box::new(ast::BinaryExp::Plus{
            lhs,
            rhs
        }))
    ),

    <lhs:Term> "DASH" <rhs:Exp> => Box::new(
        ast::Exp::BinaryExp(Box::new(ast::BinaryExp::Minus{
            lhs,
            rhs
        }))
    ),
    // Term "OR" Exp => Box::new(ast::Exp::BinaryExp(<>)),
    // Term "EQUALS" Exp => Box::new(ast::Exp::BinaryExp(<>)),
    // Term "NOTEQUALS" Exp => Box::new(ast::Exp::BinaryExp(<>)),
    // Term "GREATER" Exp => Box::new(ast::Exp::BinaryExp(<>)),
    // Term "GREATEREQ" Exp => Box::new(ast::Exp::BinaryExp(<>)),
    // Term "LESS" Exp => Box::new(ast::Exp::BinaryExp(<>)),
    // Term "LESSEQ" Exp => Box::new(ast::Exp::BinaryExp(<>)),
    // "NOT" Exp => Box::new(ast::Exp::UnaryExp(<>)), //may need to fix to Exp
    // "DASH" Term => Box::new(ast::Exp::UnaryExp(<>)),
    
};

pub CallExp: Box<ast::CallExp> = {
    <name:Loc> "LPAREN" <args:ActualsList> "RPAREN" => Box::new(
        ast::CallExp::Fn{
            name,
            args: args
        }
    ),
};

pub ActualsList = {
    Comma<Exp>
};


pub Term: Box<ast::Exp> = {
    Loc                        => Box::new(ast::Exp::Loc(<>)),
    <val:"INTLITERAL">         => Box::new(ast::Exp::IntLit(val)),
    <string:"STRINGLITERAL">   => Box::new(ast::Exp::StrLit(string)),
    <val: "TRUE">              => Box::new(ast::Exp::True),
    <val: "FALSE">             => Box::new(ast::Exp::False),
    <val: "MAGIC">             => Box::new(ast::Exp::Magic),
    "LPAREN" <e: Exp> "RPAREN" => e,
    CallExp                    => Box::new(ast::Exp::CallExp(<>)),
};

//loc
pub Loc: Box<ast::Loc> = {
    Id => Box::new(ast::Loc::Id(<>)),

    <base_class:Loc> "POSTDEC" <field_name:"ID"> => Box::new(
        ast::Loc::MemberFieldExp{
            base_class, 
            field_name
        }
    ),
};

//loc
pub Id: Box<ast::Id> = {
    <name:"ID"> => Box::new(ast::Id::Name(name))
};
