use crate::scanner::tokens::{TokenType, LexingError};
use crate::parser::ast;
//use crate::parser::lexer::LexicalError;
grammar;

extern {
  type Location = usize;
  type Error = LexingError;

  enum TokenType {
    "AND" => TokenType::AND,
    "MAGIC" => TokenType::MAGIC,
    "BOOL" => TokenType::BOOL,
    "ELSE" => TokenType::ELSE,
    "FALSE" => TokenType::FALSE,
    "IF" => TokenType::IF,
    "INT" => TokenType::INT,
    "GIVE" => TokenType::GIVE,
    "TAKE" => TokenType::TAKE,
    "OR" => TokenType::OR,
    "PERFECT" => TokenType::PERFECT,
    "RETURN" => TokenType::RETURN,
    "CLASS" => TokenType::CLASS,
    "TRUE" => TokenType::TRUE,
    "EXIT" => TokenType::EXIT,
    "VOID" => TokenType::VOID,
    "WHILE" => TokenType::WHILE,
    "ID" => TokenType::ID(<String>),
    "INTLITERAL" => TokenType::INTLITERAL(<i32>),
    "STRINGLITERAL" => TokenType::STRINGLITERAL(<String>),
    "ASSIGN" => TokenType::ASSIGN,
    "COLON" => TokenType::COLON,
    "COMMA" => TokenType::COMMA,
    "CROSS" => TokenType::CROSS,
    "DASH" => TokenType::DASH,
    "EQUALS" => TokenType::EQUALS,
    "GREATER" => TokenType::GREATER,
    "GREATEREQ" => TokenType::GREATEREQ,
    "LCURLY" => TokenType::LCURLY,
    "LESS" => TokenType::LESS,
    "LESSEQ" => TokenType::LESSEQ,
    "LPAREN" => TokenType::LPAREN,
    "NOT" => TokenType::NOT,
    "NOTEQUALS" => TokenType::NOTEQUALS,
    "POSTDEC" => TokenType::POSTDEC,
    "POSTINC" => TokenType::POSTINC,
    "RCURLY" => TokenType::RCURLY,
    "RPAREN" => TokenType::RPAREN,
    "SEMICOL" => TokenType::SEMICOL,
    "SLASH" => TokenType::SLASH,
    "STAR" => TokenType::STAR,
  }
}

Comma<T>: Vec<T> = { 
    <mut v:(<T> "COMMA")*> <e:T> => {
        v.push(e);
        return v;
    },
    => Vec::new()
};

pub Program: Box<ast::Program> = {
     <globals:Decl*> => Box::new(ast::Program{ globals } )
}

pub Decl: Box<ast::Decl> = {
    <v:VarDecl> => Box::new(ast::Decl::VarDecl(v)),
    ClassDecl => Box::new(ast::Decl::ClassDecl(<>)),
    FnDecl => Box::new(ast::Decl::FnDecl(<>)),
}

pub VarDecl: Box<ast::VarDecl> = {
    <id:Id> "COLON" <var_type: Type> "SEMICOL" => Box::new(
        ast::VarDecl::VarDecl{
            id, 
            var_type,
            init_val: None,
        }
    ),
    <id:Id> "COLON" <var_type: Type> "ASSIGN" <init_val: Exp> "SEMICOL" => Box::new(
        ast::VarDecl::VarDecl{
            id, 
            var_type,
            init_val: Some(init_val),
        }
    ),
}

pub Type: Box<ast::Type> = {
    PrimType => Box::new(ast::Type::Prim(<>)),
    Id => Box::new(ast::Type::Class(<>)),
    "PERFECT" <prim_type: PrimType> => Box::new(ast::Type::PerfectPrim(prim_type)),
    "PERFECT" <name:"ID"> => Box::new(ast::Type::PerfectClass(name)),
}

pub PrimType: ast::PrimType = {
    "INT" => ast::PrimType::Int,
    "BOOL" => ast::PrimType::Bool,
    "VOID" => ast::PrimType::Void,
}

pub ClassDecl: Box<ast::ClassDecl> = {
    <id:Id> "COLON" "CLASS" "LCURLY" <member_f:ClassBody> "RCURLY" "SEMICOL" => Box::new(
        ast::ClassDecl::Class{
            id,
            member_f: Box::new(member_f),
        }
    ),
}

pub ClassBody: Vec<Box<ast::Decl>> = {
    <mut vec:(Decl)*> <new_var:VarDecl> => {
        vec.push(Box::new(ast::Decl::VarDecl(new_var)));
        vec
    },
    <mut vec:(Decl)*> <new_fn:FnDecl> => {
        vec.push(Box::new(ast::Decl::FnDecl(new_fn)));
        vec
    },
    => Vec::<Box<ast::Decl>>::new(),
}


pub FnDecl: Box<ast::FnDecl> = {
    <id:Id> "COLON" "LPAREN" <args:FormalsList> "RPAREN" <ret:Type> "LCURLY" <body:StmtList> "RCURLY" => Box::new(
        ast::FnDecl::FnDecl_Formals{
            id, args, ret, body
        }
    ),
}

pub FormalsList = {
    Comma<FormalDecl>
    // see if we need to do epsilon later 
    // as of right now, a formalsList/formals node will NOT be created
    // this should be fine because FormalsNode/FormalsListNode isn't a thing in the inheritance/collaboration diagram
}

pub FormalDecl: Box<ast::FormalDecl> = {
    <name:"ID"> "COLON" <formal_type: Type> => Box::new(
        ast::FormalDecl::FormalDecl(name, formal_type)
    ),
}

pub StmtList: Vec<Box<ast::Stmt>> = {
    <stmts:Stmt*> => stmts
}

pub Stmt: Box<ast::Stmt> = {
    <bs:BlockStmt> => Box::new(ast::Stmt::Block(bs)),
    <s:LineStmt> "SEMICOL" => Box::new(ast::Stmt::Line(s)),
}

pub BlockStmt: Box<ast::BlockStmt> = {
    "WHILE" "LPAREN" <cond: Exp> "RPAREN" "LCURLY" <body: StmtList> "RCURLY" => Box::new(
        ast::BlockStmt::While{cond, body}
    ),
    "IF" "LPAREN" <cond: Exp> "RPAREN" "LCURLY" <body: StmtList> "RCURLY" => Box::new(
        ast::BlockStmt::If{cond, body}
    ),
    "IF" "LPAREN" <cond: Exp> "RPAREN" "LCURLY" <true_branch: StmtList> "RCURLY" 
    "ELSE" "LCURLY" <false_branch: StmtList> "RCURLY" => Box::new(
        ast::BlockStmt::IfElse{cond, true_branch, false_branch}
    ),
}

pub LineStmt: Box<ast::LineStmt> = {
    Decl                          => Box::new(ast::LineStmt::Decl(<>)),
    <dest:Loc> "ASSIGN" <src:Exp> => Box::new(ast::LineStmt::Assign { dest, src }),
    <loc:Loc> "POSTDEC"           => Box::new(ast::LineStmt::PostDec(loc)),
    <loc:Loc> "POSTINC"           => Box::new(ast::LineStmt::PostInc(loc)),
    "GIVE" <output:Exp>           => Box::new(ast::LineStmt::Give(output)),
    "TAKE" <recipient:Loc>        => Box::new(ast::LineStmt::Take(recipient)),
    "RETURN" <ret:Exp>            => Box::new(ast::LineStmt::Return(Some(ret))),
    "RETURN"                      => Box::new(ast::LineStmt::Return(None)),
    "EXIT"                        => Box::new(ast::LineStmt::Exit),
    CallExp                       => Box::new(ast::LineStmt::Call(<>)),
}

pub Exp: Box<ast::Exp> = {
    #[precedence(level="1")]
    Term,

    #[precedence(level="2")] #[assoc(side="right")]
    <lhs:Term> "STAR" <rhs:Exp> => Box::new(
        ast::Exp::BinaryExp(Box::new(ast::BinaryExp::Times{
            lhs,
            rhs
        }))
    ),

    <lhs:Term> "SLASH" <rhs:Exp> => Box::new(
        ast::Exp::BinaryExp(Box::new(ast::BinaryExp::Divide{
            lhs,
            rhs
        }))
    ),

    <lhs:Term> "AND" <rhs:Exp> => Box::new(
        ast::Exp::BinaryExp(Box::new(ast::BinaryExp::And{
            lhs,
            rhs
        }))
    ),

    #[precedence(level="3")]
    <lhs:Term> "CROSS" <rhs:Exp> => Box::new(
        ast::Exp::BinaryExp(Box::new(ast::BinaryExp::Plus{
            lhs,
            rhs
        }))
    ),

    <lhs:Term> "DASH" <rhs:Exp> => Box::new(
        ast::Exp::BinaryExp(Box::new(ast::BinaryExp::Minus{
            lhs,
            rhs
        }))
    ), 
    // Term "OR" Exp => Box::new(ast::Exp::BinaryExp(<>)),
    // Term "EQUALS" Exp => Box::new(ast::Exp::BinaryExp(<>)),
    // Term "NOTEQUALS" Exp => Box::new(ast::Exp::BinaryExp(<>)),
    // Term "GREATER" Exp => Box::new(ast::Exp::BinaryExp(<>)),
    // Term "GREATEREQ" Exp => Box::new(ast::Exp::BinaryExp(<>)),
    // Term "LESS" Exp => Box::new(ast::Exp::BinaryExp(<>)),
    // Term "LESSEQ" Exp => Box::new(ast::Exp::BinaryExp(<>)),
    // "NOT" Exp => Box::new(ast::Exp::UnaryExp(<>)), //may need to fix to Exp
    // "DASH" Term => Box::new(ast::Exp::UnaryExp(<>)),
    
};

pub CallExp: Box<ast::CallExp> = {
    <name:Loc> "LPAREN" <args:ActualsList> "RPAREN" => Box::new(
        ast::CallExp::Fn{
            name,
            args: args
        }
    ),
};

pub ActualsList = {
    Comma<Exp>
};


pub Term: Box<ast::Exp> = {
    Loc                        => Box::new(ast::Exp::Loc(<>)),
    <val:"INTLITERAL">         => Box::new(ast::Exp::IntLit(val)),
    <string:"STRINGLITERAL">   => Box::new(ast::Exp::StrLit(string)),
    <val: "TRUE">              => Box::new(ast::Exp::True),
    <val: "FALSE">             => Box::new(ast::Exp::False),
    <val: "MAGIC">             => Box::new(ast::Exp::Magic),
    "LPAREN" <e: Exp> "RPAREN" => e,
    CallExp                    => Box::new(ast::Exp::CallExp(<>)),
};

//loc
pub Loc: Box<ast::Loc> = {
    Id => Box::new(ast::Loc::Id(<>)),

    <base_class:Loc> "POSTDEC" <field_name:"ID"> => Box::new(
        ast::Loc::MemberFieldExp{
            base_class, 
            field_name
        }
    ),
};

//loc
pub Id: Box<ast::Id> = {
    <name:"ID"> => Box::new(ast::Id::Name(name))
};
