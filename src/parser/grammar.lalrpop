use crate::scanner::tokens::{TokenType, LexingError};
use crate::parser::ast::*;
use crate::parser::ast::position::Position;
grammar;

extern {
  type Location = usize;
  type Error = LexingError;

  enum TokenType {
    "AND" => TokenType::AND,
    "MAGIC" => TokenType::MAGIC,
    "BOOL" => TokenType::BOOL,
    "ELSE" => TokenType::ELSE,
    "FALSE" => TokenType::FALSE,
    "IF" => TokenType::IF,
    "INT" => TokenType::INT,
    "GIVE" => TokenType::GIVE,
    "TAKE" => TokenType::TAKE,
    "OR" => TokenType::OR,
    "PERFECT" => TokenType::PERFECT,
    "RETURN" => TokenType::RETURN,
    "CLASS" => TokenType::CLASS,
    "TRUE" => TokenType::TRUE,
    "EXIT" => TokenType::EXIT,
    "VOID" => TokenType::VOID,
    "WHILE" => TokenType::WHILE,
    "ID" => TokenType::ID(<String>),
    "INTLITERAL" => TokenType::INTLITERAL(<i32>),
    "STRINGLITERAL" => TokenType::STRINGLITERAL(<String>),
    "ASSIGN" => TokenType::ASSIGN,
    "COLON" => TokenType::COLON,
    "COMMA" => TokenType::COMMA,
    "CROSS" => TokenType::CROSS,
    "DASH" => TokenType::DASH,
    "EQUALS" => TokenType::EQUALS,
    "GREATER" => TokenType::GREATER,
    "GREATEREQ" => TokenType::GREATEREQ,
    "LCURLY" => TokenType::LCURLY,
    "LESS" => TokenType::LESS,
    "LESSEQ" => TokenType::LESSEQ,
    "LPAREN" => TokenType::LPAREN,
    "NOT" => TokenType::NOT,
    "NOTEQUALS" => TokenType::NOTEQUALS,
    "POSTDEC" => TokenType::POSTDEC,
    "POSTINC" => TokenType::POSTINC,
    "RCURLY" => TokenType::RCURLY,
    "RPAREN" => TokenType::RPAREN,
    "SEMICOL" => TokenType::SEMICOL,
    "SLASH" => TokenType::SLASH,
    "STAR" => TokenType::STAR,
  }
}

Comma<T>: Vec<T> = { 
    <mut v:(<T> "COMMA")*> <e:T> => {
        v.push(e);
        return v;
    },
    => Vec::new()
};

pub Program: Box<Program> = {
     <globals:Decl*>=> Box::new(Program{ globals } )
}

pub Decl: Box<Decl> = {
    <v:VarDecl> => Box::new(Decl::VarDecl(v)),
    ClassDecl => Box::new(Decl::ClassDecl(<>)),
    FnDecl => Box::new(Decl::FnDecl(<>)),
}

pub VarDecl: Box<VarDecl> = {
    <id:Id> "COLON" <var_type: Type> "SEMICOL" => Box::new(
        VarDecl {
            id, 
            var_type,
            init_val: None,
            // pos: id.span
        }
    ),
    <id:Id> "COLON" <var_type: Type> "ASSIGN" <init_val: Exp> "SEMICOL" => {
        Box::new(
            VarDecl {
                id, 
                var_type,
                init_val: Some(init_val),
                // pos: id.span
            }
        )
    },
}

pub Type: Box<Type> = {
    PrimType => Type::new(TypeKind::Prim(<>), false),
    Id => Type::new(TypeKind::Class(<>), false),
    "PERFECT" <prim_type: PrimType> => Type::new(TypeKind::Prim(prim_type), true),
    "PERFECT" <name:Id> => Type::new(TypeKind::Class(name), true),
}

pub PrimType: PrimType = {
    "INT" => PrimType::Int,
    "BOOL" => PrimType::Bool,
    "VOID" => PrimType::Void,
}

pub ClassDecl: Box<ClassDecl> = {
    <id:Id> "COLON" "CLASS" "LCURLY" <member_f:ClassBody> "RCURLY" "SEMICOL" => Box::new(
        ClassDecl {
            id,
            member_f: Box::new(member_f),
        }
    ),
}

pub ClassBody: Vec<Box<Decl>> = {
    <mut vec:(Decl)*> <new_var:VarDecl> => {
        vec.push(Box::new(Decl::VarDecl(new_var)));
        vec
    },
    <mut vec:(Decl)*> <new_fn:FnDecl> => {
        vec.push(Box::new(Decl::FnDecl(new_fn)));
        vec
    },
    => Vec::<Box<Decl>>::new(),
}


pub FnDecl: Box<FnDecl> = {
    <id:Id> "COLON" "LPAREN" <args:FormalsList> "RPAREN" <ret:Type> "LCURLY" <body:StmtList> "RCURLY" => Box::new(
        FnDecl {
            id, args, ret, body
        }
    ),
}

pub FormalsList = {
    Comma<FormalDecl>
    // see if we need to do epsilon later 
    // as of right now, a formalsList/formals node will NOT be created
    // this should be fine because FormalsNode/FormalsListNode isn't a thing in the inheritance/collaboration diagram
}

pub FormalDecl: Box<FormalDecl> = {
    <id:Id> "COLON" <formal_type: Type> => Box::new(
        FormalDecl::FormalDecl {
            id, 
            formal_type
        }
    ),
}

pub StmtList: Vec<Box<Stmt>> = {
    <stmts:Stmt*> => stmts
}

pub Stmt: Box<Stmt> = {
    <bs:BlockStmt> => Box::new(Stmt::Block(bs)),
    <s:LineStmt> "SEMICOL" => Box::new(Stmt::Line(s)),
    VarDecl => Box::new(Stmt::VarDecl(<>)),
}

pub BlockStmt: Box<BlockStmt> = {
    "WHILE" "LPAREN" <cond: Exp> "RPAREN" "LCURLY" <body: StmtList> "RCURLY" => Box::new(
        BlockStmt::While{cond, body}
    ),
    "IF" "LPAREN" <cond: Exp> "RPAREN" "LCURLY" <body: StmtList> "RCURLY" => Box::new(
        BlockStmt::If{cond, body}
    ),
    "IF" "LPAREN" <cond: Exp> "RPAREN" "LCURLY" <true_branch: StmtList> "RCURLY" 
    "ELSE" "LCURLY" <false_branch: StmtList> "RCURLY" => Box::new(
        BlockStmt::IfElse{cond, true_branch, false_branch}
    ),
}

pub LineStmt: Box<LineStmt> = {
    <dest:Loc> "ASSIGN" <src:Exp> => Box::new(LineStmt::Assign{dest, src}),
    <loc:Loc> "POSTDEC"           => Box::new(LineStmt::PostDec{loc}),
    <loc:Loc> "POSTINC"           => Box::new(LineStmt::PostInc{loc}),
    "GIVE" <output:Exp>           => Box::new(LineStmt::Give{output}),
    "TAKE" <recipient:Loc>        => Box::new(LineStmt::Take{recipient}),
    "RETURN" <result:Exp>         => Box::new(LineStmt::Return{result: Some(result)}),
    "RETURN"                      => Box::new(LineStmt::Return{result: None}),
    "EXIT"                        => Box::new(LineStmt::Exit),
    CallExp                       => Box::new(LineStmt::Call(<>)),
}

pub Exp: Box<Exp> = {
    // #[precedence(level="2")] #[assoc(side="right")]
    <lhs:Term> "EQUALS" <rhs:Exp> => Exp::new(
        Box::new(ExpKind::BinaryExp(BinaryExp::new(
            lhs,
            rhs,
            BinaryExpKind::Equals
        )))
    ),

    <lhs:Term> "NOTEQUALS" <rhs:Exp> => Exp::new(
        Box::new(ExpKind::BinaryExp(BinaryExp::new(
            lhs,
            rhs,
            BinaryExpKind::NotEquals
        )))
    ),

    <lhs:Term> "GREATER" <rhs:Exp> => Exp::new(
        Box::new(ExpKind::BinaryExp(BinaryExp::new(
            lhs,
            rhs,
            BinaryExpKind::Greater
        )))
    ),

    <lhs:Term> "GREATEREQ" <rhs:Exp> => Exp::new(
        Box::new(ExpKind::BinaryExp(BinaryExp::new(
            lhs,
            rhs,
            BinaryExpKind::GreaterEq
        )))
    ),

    <lhs:Term> "LESS" <rhs:Exp> => Exp::new(
        Box::new(ExpKind::BinaryExp(BinaryExp::new(
            lhs,
            rhs,
            BinaryExpKind::Less
        )))
    ),

    <lhs:Term> "LESSEQ" <rhs:Exp> => Exp::new(
        Box::new(ExpKind::BinaryExp(BinaryExp::new(
            lhs,
            rhs,
            BinaryExpKind::LessEq
        )))
    ),

    // #[precedence(level="1")]
    BabyExp,
};

pub BabyExp: Box<Exp> = {
    <lhs:Term> "DASH" <rhs:Exp> => Exp::new(
        Box::new(ExpKind::BinaryExp(BinaryExp::new(
            lhs,
            rhs,
            BinaryExpKind::Minus
        )))
    ),

    <lhs:Term> "CROSS" <rhs:Exp> => Exp::new(
        Box::new(ExpKind::BinaryExp(BinaryExp::new(
            lhs,
            rhs,
            BinaryExpKind::Plus
        )))
    ),

    <lhs:Term> "STAR" <rhs:Exp> => Exp::new(
        Box::new(ExpKind::BinaryExp(BinaryExp::new(
            lhs,
            rhs,
            BinaryExpKind::Times
        )))
    ),

    <lhs:Term> "SLASH" <rhs:Exp> => Exp::new(
        Box::new(ExpKind::BinaryExp(BinaryExp::new(
            lhs,
            rhs,
            BinaryExpKind::Divide
        )))
    ),

    <lhs:Term> "AND" <rhs:Exp> => Exp::new(
        Box::new(ExpKind::BinaryExp(BinaryExp::new(
            lhs,
            rhs,
            BinaryExpKind::And
        )))
    ), 

    <lhs:Term> "OR" <rhs:Exp> => Exp::new(
        Box::new(ExpKind::BinaryExp(BinaryExp::new(
            lhs,
            rhs,
            BinaryExpKind::Or
        )))
    ), 

    "NOT" <exp:Exp> => Exp::new(
        Box::new(ExpKind::UnaryExp(UnaryExp::new(
            exp,
            UnaryExpKind::Not
        )))
    ), 

    "DASH" <exp:Exp> => Exp::new(
        Box::new(ExpKind::UnaryExp(UnaryExp::new(
            exp,
            UnaryExpKind::Neg
        )))
    ), 
    
    Term,
};

pub CallExp: Box<CallExp> = {
    <name:Loc> "LPAREN" <args:ActualsList> "RPAREN" => Box::new(
        CallExp {
            name,
            args: args
        }
    ),
};

pub ActualsList = {
    Comma<Exp>
};


pub Term: Box<Exp> = {
    Loc                        => Exp::new(ExpKind::new(ExpKind::Loc(<>))),
    <val:"INTLITERAL">         => Exp::new(ExpKind::new(ExpKind::IntLit(val))),
    <string:"STRINGLITERAL">   => Exp::new(ExpKind::new(ExpKind::StrLit(string))),
    "TRUE"                     => Exp::new(ExpKind::new(ExpKind::True)),
    "FALSE"                    => Exp::new(ExpKind::new(ExpKind::False)),
    "MAGIC"                    => Exp::new(ExpKind::new(ExpKind::Magic)),
    "LPAREN" <e: Exp> "RPAREN" => e,
    CallExp                    => Exp::new(ExpKind::new(ExpKind::CallExp(<>))),
};

//loc
pub Loc: Box<Loc> = {
    Id => Box::new(Loc::Id(<>)),
    <base_class:Loc> "POSTDEC" <field_name:Id> => Box::new(Loc::Loc{base_class, field_name}),
};

//loc
pub Id: Box<Id> = {
    <l:@L> <name:"ID"> <r:@R> => Box::new(Id{name, position: Position::new(l, r)})
};
