use crate::scanner::tokens::{TokenType, LexingError};
use crate::parser::ast;
//use crate::parser::lexer::LexicalError;
grammar;

extern {
  type Location = usize;
  type Error = LexingError;

  enum TokenType {
    "AND" => TokenType::AND,
    "MAGIC" => TokenType::MAGIC,
    "BOOL" => TokenType::BOOL,
    "ELSE" => TokenType::ELSE,
    "FALSE" => TokenType::FALSE,
    "IF" => TokenType::IF,
    "INT" => TokenType::INT,
    "GIVE" => TokenType::GIVE,
    "TAKE" => TokenType::TAKE,
    "OR" => TokenType::OR,
    "PERFECT" => TokenType::PERFECT,
    "RETURN" => TokenType::RETURN,
    "CLASS" => TokenType::CLASS,
    "TRUE" => TokenType::TRUE,
    "EXIT" => TokenType::EXIT,
    "VOID" => TokenType::VOID,
    "WHILE" => TokenType::WHILE,
    "ID" => TokenType::ID(<String>),
    "INTLITERAL" => TokenType::INTLITERAL(<i32>),
    "STRINGLITERAL" => TokenType::STRINGLITERAL(<String>),
    "ASSIGN" => TokenType::ASSIGN,
    "COLON" => TokenType::COLON,
    "COMMA" => TokenType::COMMA,
    "CROSS" => TokenType::CROSS,
    "DASH" => TokenType::DASH,
    "EQUALS" => TokenType::EQUALS,
    "GREATER" => TokenType::GREATER,
    "GREATEREQ" => TokenType::GREATEREQ,
    "LCURLY" => TokenType::LCURLY,
    "LESS" => TokenType::LESS,
    "LESSEQ" => TokenType::LESSEQ,
    "LPAREN" => TokenType::LPAREN,
    "NOT" => TokenType::NOT,
    "NOTEQUALS" => TokenType::NOTEQUALS,
    "POSTDEC" => TokenType::POSTDEC,
    "POSTINC" => TokenType::POSTINC,
    "RCURLY" => TokenType::RCURLY,
    "RPAREN" => TokenType::RPAREN,
    "SEMICOL" => TokenType::SEMICOL,
    "SLASH" => TokenType::SLASH,
    "STAR" => TokenType::STAR,
  }
}

//program
pub Program: Box<ast::Program> = {
    Globals => Box::new(ast::Program::Program(<>)),
}

//globals
pub Globals: Box<ast::Globals> = {
    Globals Decl => Box::new(ast::Globals::Globals_Decl(<>)),
    => Box::new(ast::Globals::Globals_Epsilon(<>)),
}

//decl
pub Decl: Box<ast::Decl> = {
    VarDecl "SEMICOL" => Box::new(ast::Decl::Decl_VarDecl(<>)),
    ClassDecl => Box::new(ast::Decl::Decl_ClassDecl(<>)),
    FnDecl => Box::new(ast::Decl::Decl_FnDecl(<>)),
}

//VarDecl
pub VarDecl: Box<ast::VarDecl> = {
    Id "COLON" Type => Box::new(ast::VarDecl::VarDecl_Colon(<>)),
    Id "COLON" Type "ASSIGN" Exp => Box::new(ast::VarDecl::VarDecl_ColonAssign(<>)),
}

//type
pub Type: Box<ast::Type> = {
    PrimType => Box::new(ast::Type::Type_PrimType(<>)),
    "PERFECT" PrimType => Box::new(ast::Type::Type_PerfectPrimType(<>)),
    Id => Box::new(ast::Type::Type_Id(<>)),
    "PERFECT" Id => Box::new(ast::Type::Type_PerfectId(<>)),

}

//PrimType
pub PrimType: Box<ast::PrimType> = {
    "INT" => Box::new(ast::PrimType::PrimType_Int(<>)),
    "BOOL" => Box::new(ast::PrimType::PrimType_Bool(<>)),
    "VOID" => Box::new(ast::PrimType::PrimType_Void(<>)),
}

//ClassDecl
pub ClassDecl: Box<ast::ClassDecl> = {
    Id "COLON" "CLASS" "LCURLY" ClassBody "RCURLY" "SEMICOL" => Box::new(ast::ClassDecl::ClassDecl(<>)),
}

//classBody
pub ClassBody: Box<ast::ClassBody> = {
    ClassBody VarDecl "SEMICOL" => Box::new(ast::ClassBody::ClassBody_VarDecl(<>)),
    ClassBody FnDecl "SEMICOL" => Box::new(ast::ClassBody::ClassBody_FnDecl(<>)),
    => Box::new(ast::ClassBody::ClassBody_Epsilon(<>)),

}

//FnDecl
pub FnDecl: Box<ast::FnDecl> = {
    Id "COLON" "LPAREN" Formals "RPAREN" Type "LCURLY" StmtList "RCURLY" => Box::new(ast::FnDecl::FnDecl_Formals(<>)),
    //Id "COLON" "LPAREN" "RPAREN" Type "LCURLY" StmtList "RCURLY" => Box::new(ast::FnDecl::FnDecl(<>)),

}

//formals
pub Formals: Box<ast::Formals> = {
    FormalsList => Box::new(ast::Formals::Formals_FormalsList(<>)),
   => Box::new(ast::Formals::Formals_Epsilon(<>)),
}

//formalsList
pub FormalsList: Box<ast::FormalsList> = {
    FormalDecl => Box::new(ast::FormalsList::FormalsList_FormalDecl(<>)),
    FormalsList "COMMA" FormalDecl => Box::new(ast::FormalsList::FormalsList(<>)),

}

//formalDecl
pub FormalDecl: Box<ast::FormalDecl> = {
    Id "COLON" Type => Box::new(ast::FormalDecl::FormalDecl(<>)),
}


//stmtList
pub StmtList: Box<ast::StmtList> = {
    StmtList Stmt "SEMICOL" => Box::new(ast::StmtList::StmtList_StmtList(<>)),
    StmtList BlockStmt => Box::new(ast::StmtList::StmtList_BlockStmt(<>)),
    => Box::new(ast::StmtList::StmtList_Epsilon(<>)),
}

//blockStmt
pub BlockStmt: Box<ast::BlockStmt> = {
    "WHILE" "LPAREN" Exp "RPAREN" "LCURLY" StmtList "RCURLY" => Box::new(ast::BlockStmt::BlockStmt_While(<>)),
    "IF" "LPAREN" Exp "RPAREN" "LCURLY" StmtList "RCURLY" => Box::new(ast::BlockStmt::BlockStmt_If(<>)),
    "IF" "LPAREN" Exp "RPAREN" "LCURLY" StmtList "RCURLY" "ELSE" "LCURLY" StmtList "RCURLY" => Box::new(ast::BlockStmt::BlockStmt_IfElse(<>)),
}

//stmt
pub Stmt: Box<ast::Stmt> = {
    VarDecl => Box::new(ast::Stmt::Stmt_VarDecl(<>)),
    Loc "ASSIGN" Exp => Box::new(ast::Stmt::Stmt_Assign(<>)),
    Loc "POSTDEC" => Box::new(ast::Stmt::Stmt_PostDec(<>)),
    Loc "POSTINC" => Box::new(ast::Stmt::Stmt_PostInc(<>)),
    "GIVE" Exp => Box::new(ast::Stmt::Stmt_Give(<>)),
    "TAKE" Loc => Box::new(ast::Stmt::Stmt_Take(<>)),
    "RETURN" Exp => Box::new(ast::Stmt::Stmt_ReturnExp(<>)),
    "RETURN" => Box::new(ast::Stmt::Stmt_Return(<>)),
    "EXIT" => Box::new(ast::Stmt::Stmt_Exit(<>)),
    CallExp => Box::new(ast::Stmt::Stmt_CallExp(<>)),
}

//Exp
pub Exp: Box<ast::Exp> = {
    Term "DASH" Exp => Box::new(ast::Exp::Exp_Dash(<>)),
    Term "CROSS" Exp => Box::new(ast::Exp::Exp_Cross(<>)),
    Term "STAR" Exp => Box::new(ast::Exp::Exp_Star(<>)),
    Term "SLASH" Exp => Box::new(ast::Exp::Exp_Slash(<>)),
    Term "AND" Exp => Box::new(ast::Exp::Exp_And(<>)),
    Term "OR" Exp => Box::new(ast::Exp::Exp_Or(<>)),
    Term "EQUALS" Exp => Box::new(ast::Exp::Exp_Equals(<>)),
    Term "NOTEQUALS" Exp => Box::new(ast::Exp::Exp_NotEquals(<>)),
    Term "GREATER" Exp => Box::new(ast::Exp::Exp_Greater(<>)),
    Term "GREATEREQ" Exp => Box::new(ast::Exp::Exp_GreaterEq(<>)),
    Term "LESS" Exp => Box::new(ast::Exp::Exp_Less(<>)),
    Term "LESSEQ" Exp => Box::new(ast::Exp::Exp_LessEq(<>)),
    "NOT" Exp => Box::new(ast::Exp::Exp_Not(<>)), //may need to fix to Exp
    "DASH" Term => Box::new(ast::Exp::Exp_DashTerm(<>)),
    Term => Box::new(ast::Exp::Exp_Term(<>)),

};

//callExp
pub CallExp: Box<ast::CallExp> = {
    Id "LPAREN" "RPAREN" => Box::new(ast::CallExp::CallExp_Fn(<>)),
    Id "LPAREN" ActualsList "RPAREN" => Box::new(ast::CallExp::CallExp_FnArgs(<>)),
};

//actualsList
pub ActualsList: Box<ast::ActualsList> = {
    Exp => Box::new(ast::ActualsList::ActualsList_Exp(<>)),
    ActualsList "COMMA" Exp => Box::new(ast::ActualsList::ActualsList_ActualsList(<>)),
};


//term
pub Term: Box<ast::Term> = {
    Loc=> Box::new(ast::Term::Term_Loc(<>)),
    <val:"INTLITERAL"> => Box::new(ast::Term::Term_IntLiteral(val)),
    <string:"STRINGLITERAL"> => Box::new(ast::Term::Term_StringLiteral(string)),
    "TRUE" => Box::new(ast::Term::Term_True(TokenType::TRUE)),
    "FALSE" => Box::new(ast::Term::Term_False(TokenType::FALSE)),
    "MAGIC" => Box::new(ast::Term::Term_Magic(TokenType::MAGIC)),
    "LPAREN" Exp "RPAREN" => Box::new(ast::Term::Term_Paren(<>)),
    CallExp => Box::new(ast::Term::Term_CallExp(<>)),

};

//loc
pub Loc: Box<ast::Loc> = {
    Id => Box::new(ast::Loc::Loc_Id(<>)),
    Loc "POSTDEC" Id => Box::new(ast::Loc::Loc_PostDec(<>)),
};

//id
pub Id: Box<ast::Id> = {
    <name:"ID"> => Box::new(ast::Id::Id(name)),
};
