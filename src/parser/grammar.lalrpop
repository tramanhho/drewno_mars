use crate::scanner::tokens::{TokenType, LexingError};
use crate::parser::ast;
use crate::parser::ast::position::Position;
grammar;

extern {
  type Location = usize;
  type Error = LexingError;

  enum TokenType {
    "AND" => TokenType::AND,
    "MAGIC" => TokenType::MAGIC,
    "BOOL" => TokenType::BOOL,
    "ELSE" => TokenType::ELSE,
    "FALSE" => TokenType::FALSE,
    "IF" => TokenType::IF,
    "INT" => TokenType::INT,
    "GIVE" => TokenType::GIVE,
    "TAKE" => TokenType::TAKE,
    "OR" => TokenType::OR,
    "PERFECT" => TokenType::PERFECT,
    "RETURN" => TokenType::RETURN,
    "CLASS" => TokenType::CLASS,
    "TRUE" => TokenType::TRUE,
    "EXIT" => TokenType::EXIT,
    "VOID" => TokenType::VOID,
    "WHILE" => TokenType::WHILE,
    "ID" => TokenType::ID(<String>),
    "INTLITERAL" => TokenType::INTLITERAL(<i32>),
    "STRINGLITERAL" => TokenType::STRINGLITERAL(<String>),
    "ASSIGN" => TokenType::ASSIGN,
    "COLON" => TokenType::COLON,
    "COMMA" => TokenType::COMMA,
    "CROSS" => TokenType::CROSS,
    "DASH" => TokenType::DASH,
    "EQUALS" => TokenType::EQUALS,
    "GREATER" => TokenType::GREATER,
    "GREATEREQ" => TokenType::GREATEREQ,
    "LCURLY" => TokenType::LCURLY,
    "LESS" => TokenType::LESS,
    "LESSEQ" => TokenType::LESSEQ,
    "LPAREN" => TokenType::LPAREN,
    "NOT" => TokenType::NOT,
    "NOTEQUALS" => TokenType::NOTEQUALS,
    "POSTDEC" => TokenType::POSTDEC,
    "POSTINC" => TokenType::POSTINC,
    "RCURLY" => TokenType::RCURLY,
    "RPAREN" => TokenType::RPAREN,
    "SEMICOL" => TokenType::SEMICOL,
    "SLASH" => TokenType::SLASH,
    "STAR" => TokenType::STAR,
  }
}

Comma<T>: Vec<T> = { 
    <mut v:(<T> "COMMA")*> <e:T> => {
        v.push(e);
        return v;
    },
    => Vec::new()
};

pub Program: Box<ast::Program> = {
     <globals:Decl*>=> Box::new(ast::Program{ globals } )
}

pub Decl: Box<ast::Decl> = {
    <v:VarDecl> => Box::new(ast::Decl::VarDecl(v)),
    ClassDecl => Box::new(ast::Decl::ClassDecl(<>)),
    FnDecl => Box::new(ast::Decl::FnDecl(<>)),
}

pub VarDecl: Box<ast::VarDecl> = {
    <id:Id> "COLON" <var_type: Type> "SEMICOL" => Box::new(
        ast::VarDecl {
            id, 
            var_type,
            init_val: None,
            // pos: id.span
        }
    ),
    <id:Id> "COLON" <var_type: Type> "ASSIGN" <init_val: Exp> "SEMICOL" => {
        Box::new(
            ast::VarDecl {
                id, 
                var_type,
                init_val: Some(init_val),
                // pos: id.span
            }
        )
    },
}

pub Type: Box<ast::Type> = {
    PrimType => Box::new(ast::Type::Prim(<>)),
    Id => Box::new(ast::Type::Class(<>)),
    "PERFECT" <prim_type: PrimType> => Box::new(ast::Type::PerfectPrim(prim_type)),
    "PERFECT" <name:Id> => Box::new(ast::Type::PerfectClass(name)),
}

pub PrimType: ast::PrimType = {
    "INT" => ast::PrimType::Int,
    "BOOL" => ast::PrimType::Bool,
    "VOID" => ast::PrimType::Void,
}

pub ClassDecl: Box<ast::ClassDecl> = {
    <id:Id> "COLON" "CLASS" "LCURLY" <member_f:ClassBody> "RCURLY" "SEMICOL" => Box::new(
        ast::ClassDecl {
            id,
            member_f: Box::new(member_f),
        }
    ),
}

pub ClassBody: Vec<Box<ast::Decl>> = {
    <mut vec:(Decl)*> <new_var:VarDecl> => {
        vec.push(Box::new(ast::Decl::VarDecl(new_var)));
        vec
    },
    <mut vec:(Decl)*> <new_fn:FnDecl> => {
        vec.push(Box::new(ast::Decl::FnDecl(new_fn)));
        vec
    },
    => Vec::<Box<ast::Decl>>::new(),
}


pub FnDecl: Box<ast::FnDecl> = {
    <id:Id> "COLON" "LPAREN" <args:FormalsList> "RPAREN" <ret:Type> "LCURLY" <body:StmtList> "RCURLY" => Box::new(
        ast::FnDecl {
            id, args, ret, body
        }
    ),
}

pub FormalsList = {
    Comma<FormalDecl>
    // see if we need to do epsilon later 
    // as of right now, a formalsList/formals node will NOT be created
    // this should be fine because FormalsNode/FormalsListNode isn't a thing in the inheritance/collaboration diagram
}

pub FormalDecl: Box<ast::FormalDecl> = {
    <id:Id> "COLON" <formal_type: Type> => Box::new(
        ast::FormalDecl::FormalDecl {
            id, 
            formal_type
        }
    ),
}

pub StmtList: Vec<Box<ast::Stmt>> = {
    <stmts:Stmt*> => stmts
}

pub Stmt: Box<ast::Stmt> = {
    <bs:BlockStmt> => Box::new(ast::Stmt::Block(bs)),
    <s:LineStmt> "SEMICOL" => Box::new(ast::Stmt::Line(s)),
    VarDecl => Box::new(ast::Stmt::VarDecl(<>)),
}

pub BlockStmt: Box<ast::BlockStmt> = {
    "WHILE" "LPAREN" <cond: Exp> "RPAREN" "LCURLY" <body: StmtList> "RCURLY" => Box::new(
        ast::BlockStmt::While{cond, body}
    ),
    "IF" "LPAREN" <cond: Exp> "RPAREN" "LCURLY" <body: StmtList> "RCURLY" => Box::new(
        ast::BlockStmt::If{cond, body}
    ),
    "IF" "LPAREN" <cond: Exp> "RPAREN" "LCURLY" <true_branch: StmtList> "RCURLY" 
    "ELSE" "LCURLY" <false_branch: StmtList> "RCURLY" => Box::new(
        ast::BlockStmt::IfElse{cond, true_branch, false_branch}
    ),
}

pub LineStmt: Box<ast::LineStmt> = {
    <dest:Loc> "ASSIGN" <src:Exp> => Box::new(ast::LineStmt::Assign{dest, src}),
    <loc:Loc> "POSTDEC"           => Box::new(ast::LineStmt::PostDec{loc}),
    <loc:Loc> "POSTINC"           => Box::new(ast::LineStmt::PostInc{loc}),
    "GIVE" <output:Exp>           => Box::new(ast::LineStmt::Give{output}),
    "TAKE" <recipient:Loc>        => Box::new(ast::LineStmt::Take{recipient}),
    "RETURN" <result:Exp>         => Box::new(ast::LineStmt::Return{result: Some(result)}),
    "RETURN"                      => Box::new(ast::LineStmt::Return{result: None}),
    "EXIT"                        => Box::new(ast::LineStmt::Exit),
    CallExp                       => Box::new(ast::LineStmt::Call(<>)),
}

pub Exp: Box<ast::Exp> = {
    // #[precedence(level="2")] #[assoc(side="right")]
    <lhs:Term> "EQUALS" <rhs:Exp> => Box::new(
        ast::Exp::BinaryExp(Box::new(ast::BinaryExp::Equals{
            lhs,
            rhs
        }))
    ),

    <lhs:Term> "NOTEQUALS" <rhs:Exp> => Box::new(
        ast::Exp::BinaryExp(Box::new(ast::BinaryExp::NotEquals{
            lhs,
            rhs
        }))
    ),

    <lhs:Term> "GREATER" <rhs:Exp> => Box::new(
        ast::Exp::BinaryExp(Box::new(ast::BinaryExp::Greater{
            lhs,
            rhs
        }))
    ),

    <lhs:Term> "GREATEREQ" <rhs:Exp> => Box::new(
        ast::Exp::BinaryExp(Box::new(ast::BinaryExp::GreaterEq{
            lhs,
            rhs
        }))
    ),

    <lhs:Term> "LESS" <rhs:Exp> => Box::new(
        ast::Exp::BinaryExp(Box::new(ast::BinaryExp::Less{
            lhs,
            rhs
        }))
    ),

    <lhs:Term> "LESSEQ" <rhs:Exp> => Box::new(
        ast::Exp::BinaryExp(Box::new(ast::BinaryExp::LessEq{
            lhs,
            rhs
        }))
    ),

    // #[precedence(level="1")]
    BabyExp,
};

pub BabyExp: Box<ast::Exp> = {
    <lhs:Term> "DASH" <rhs:Exp> => Box::new(
        ast::Exp::BinaryExp(Box::new(ast::BinaryExp::Minus{
            lhs,
            rhs
        }))
    ), 

    <lhs:Term> "CROSS" <rhs:Exp> => Box::new(
        ast::Exp::BinaryExp(Box::new(ast::BinaryExp::Plus{
            lhs,
            rhs
        }))
    ),

    <lhs:Term> "STAR" <rhs:Exp> => Box::new(
        ast::Exp::BinaryExp(Box::new(ast::BinaryExp::Times{
            lhs,
            rhs
        }))
    ),

    <lhs:Term> "SLASH" <rhs:Exp> => Box::new(
        ast::Exp::BinaryExp(Box::new(ast::BinaryExp::Divide{
            lhs,
            rhs
        }))
    ),

    <lhs:Term> "AND" <rhs:Exp> => Box::new(
        ast::Exp::BinaryExp(Box::new(ast::BinaryExp::And{
            lhs,
            rhs
        }))
    ), 

    <lhs:Term> "OR" <rhs:Exp> => Box::new(
        ast::Exp::BinaryExp(Box::new(ast::BinaryExp::Or{
            lhs,
            rhs
        }))
    ), 

    "NOT" <exp:Exp> => Box::new(
        ast::Exp::UnaryExp(Box::new(ast::UnaryExp::Not{
            exp
        }))
    ), 

    "DASH" <exp:Exp> => Box::new(
        ast::Exp::UnaryExp(Box::new(ast::UnaryExp::Neg{
            exp
        }))
    ), 
    
    Term,
};

pub CallExp: Box<ast::CallExp> = {
    <name:Loc> "LPAREN" <args:ActualsList> "RPAREN" => Box::new(
        ast::CallExp {
            name,
            args: args
        }
    ),
};

pub ActualsList = {
    Comma<Exp>
};


pub Term: Box<ast::Exp> = {
    Loc                        => Box::new(ast::Exp::Loc(<>)),
    <val:"INTLITERAL">         => Box::new(ast::Exp::IntLit(val)),
    <string:"STRINGLITERAL">   => Box::new(ast::Exp::StrLit(string)),
    "TRUE"                     => Box::new(ast::Exp::True),
    "FALSE"                    => Box::new(ast::Exp::False),
    "MAGIC"                    => Box::new(ast::Exp::Magic),
    "LPAREN" <e: Exp> "RPAREN" => e,
    CallExp                    => Box::new(ast::Exp::CallExp(<>)),
};

//loc
pub Loc: Box<ast::Loc> = {
    Id => Box::new(ast::Loc::Id(<>)),
    <base_class:Loc> "POSTDEC" <field_name:Id> => Box::new(ast::Loc::Loc{base_class, field_name}),
};

//loc
pub Id: Box<ast::Id> = {
    <l:@L> <name:"ID"> <r:@R> => Box::new(ast::Id{name, position: Position::new(l, r)})
};
